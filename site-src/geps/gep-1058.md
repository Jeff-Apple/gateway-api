# GEP-1058: Route Inclusion and Delegation

- Issue: [#1058](https://github.com/kubernetes-sigs/gateway-api/issues/1058)
- Status: Proposed

## TLDR

Add support for a 2-tier hierarchy of route configuration to allow partial
delegation of route settings and, provide more flexibility in how route
configurations are organized and managed.

## Goals

- Provide a 2-tier hierarchy of route configuration to allow partial delegation
of route settings.
- Allow a route owner to limit the scope of a specific delegation.
- Provide a method to reuse a subset of route configuration across multiple routes
- Minimize the changes to the existing Gateway API
- Focus on httpRoute but create a design pattern that can be applied to other 
route types in the future

## Non-Goals

<!-- *********  Still need to fill this in ******** -->

## Terminology

- **Route**: A generic substitute for the type of route. Equivalent to saying,
“a route of type [*type*]”
- **Parent Route:** A `Route` that specifies a listener as its parentRef object
and is listed as a parentRef object in a different Route. Technically, a parent
route is any route that has a non-nil AllowedRoutes block
- **Child Route:** A Route that lists a Route as its parentRef object.
- **Delegation:** when an included route crosses a persona ownership boundary
(e.g. a parent route is managed by an infrastructure team and a child route is
managed by an app dev team)
- **Inclusion:** When a child Route’s configuration is combined with a parent
Route’s config during runtime. The two routes may or may not be owned by the same
persona or organization. All delegations are inclusions, but not all inclusions
are delegations.  

## Introduction
This proposal adds support for creating parent/child relationships between
multiple routes. This solves two use cases. First, a common subset of a route
configuration can be defined once and used by multiple routes. This can
significantly reduce the effort needed to make the same change to multiple routes.
The second use case is allowing the owner of a route to delegate responsibility
for portions of the route configuration. 

This proposal is specifically focused on httpRoutes but creates a design
pattern that can be applied to other route types in the future. For this reason,
this GEP primarily uses the generic term “Route” instead of using httpRoute.

## Use Cases

There are two primary use cases that this proposal is intended to address. There
are also a number of secondary use cases that are a combination of the two
primary ones. The twp primary use cases are described below.

The diagram below is an example scenario that is referred to
throughput this document and the example configurations are based on it.

**Example Scenario 1:**  
![Example Scenario 1](images/1058-example-scenario.png "Example Scenario 1")

### 1. Partial Administrative Delegation of Routing

There are scenarios where there is a need to divide responsibility for route
configuration across multiple users and/or groups.

Using Scenario 1 as an example, there are four groups of administrative users,
one for each name space. The `prod-gw` namespace is managed by the NetOps team
and the other three admin groups are the Application Owners, each with their own
namespace.

The NetOps team has a single Listener that handles all HTTP-based traffic for
the host www.example.com but they want to manage route configuration only enough
to ensure traffic is sent to the correct namespace. The NetOps team wants to
delegate the rest of the route configuration to the application owners.

It should be noted that both the NetOpts team and the Application teams may need
to configure more features of httpRoute than just matching rules. Examples of
this are header manipulation and path rewriting.

### 2. Compose routes from reusable config fragments

Another use case is where there is a group of route config settings that are
common across multiple Routes of the same type (e.g. httpRoute). Users want to
be able to have the Routes include that group of config settings by reference
instead of having to embed those settings directly in each Route or RouteRule.

The configurations for Scenario 1 (show lower on this page), demonstrate two
ways this technique can be used. In the first case, traffic needs to be routed
to "Core Services" (`core-svces-ns`) from two different starting points. Using
route inclusion, the routing configuration for the Core Services are put in a
child route and then that child route is included in two sections of a parent
route where they are needed. 

Another way route inclusion is used in Scenario 1 is by configuring a
HTTPRouteFilter, that inserts a header, in the parent route. This results in the
filter being added to each RouteRule in the child route `store-route`. The child
route is both shorter and easier to read than it would have been without this
technique.

This use case and the Delegation use case are solved using the same mechanism
(route inclusion). They differ only in the intention (i.e. purpose) for using
that mechanism.

One advantage of allowing Routes to include groups of settings by reference is
that, when one of those settings needs to be changed, it only has to be changed
in one place instead of editing all of the relevant Routes. Another advantage is
that it prevents those settings from diverging across the Routes over time.

The remainder of this document covers the proposed enhancements to the Gateway API.

## Patent/Child Route Relationships

The proposal is to allow the settings in a child route to be combined with a
section of the parent route’s RouteRule.   A HTTPRouteRule may have either
BackendRefs or AllowedRoutes set. The effect of this is that a Route can
delegate to other Routes. These routes will be referred to as the parent and
child routes. This model would be more consistent with the current Route to
Gateway binding model (as documented in [GEP 724][gep-724]) than alternatives
such as "route inclusion". It allows minimal coordination from the team
implementing the child route while remaining within a scope defined by a gateway
operator, and centralizes configuration on the Route object, avoiding the need
for a ReferencePolicy.

### Summary of Changes, Requirements and Constraints: Parent/Child Route Relationships

This section details the changes to the standard to support Parent/Child routes
and the rules that govern those relationships.

(Note: A separate section covers the rules for how parent and child routes are
logically combined at runtime.)

Before getting to those details, the following two fragments of configuration
show how a parent/child route relationship is created. These are based on the
Scenario 1 diagram shown previously.

```yaml
#### Parent Route #####
kind: HTTPRoute
metadata:
  name: my-example
  namespace: prod-gw
spec:
  parentRefs:
    name:  prod-web-gw
  hostname: www.example.com
  rules:
  ...
    - name: store
...
      allowedRoutes:
      namespaces:
        from: Selector
        selector:
          matchExpressions:
          - key: kubernetes.io/metadata.name
            operator: In
            values: [store-ns, core-svces-ns]
...

#### Child 1 - store route
kind: HTTPRoute
metadata:
  name: store-route
  namespace: store-ns
spec:
  parentRefs:
    kind: HTTPRoute
    name: my-example
    namespace: prod-gw
    sectionName: store
...
```

Here are the changes and related rules:

1. Support for Parent/child Route relationships is an "Exteneded" feature in the
   Gateway API specification
2. Add `AllowedRoutes` to [HTTPRouteRule][httpRouteRule] as optional
    1. Default value is nil
    2. A single `RouteRule` can contain `BackendRefs` OR `AllowedRoutes`
    3. A parent `Route` may include `RouteRules` that use `BackendRefs` **AND**
       `RouteRules` that use `AllowedRoutes`.
    4. `AllowedRoutes` MUST be non-nil in a `RouteRule` to permit child `Routes`
       to attach to that `RouteRule`.
        1. Explanation: A parent `Route` will allow delegation to one or more
           child `Routes` by specifying `AllowedRoutes` where `BackendRef` would
           be used otherwise.
    5. Multiple child routes may attach to a single RouteRule, as long as they
       are distinct.
3. Allow a Route’s `ParentRef` Kind to be the same type as the Route’s type
    1. `Kind` is required when the `ParentRefs` is a route. `Kind` wil default to
       `gateway` (current behavior)
4. Add `Name` (type is [SectionName][sectionName]) to
   [HTTPRouteRule][httpRouteRule] as optional
    1. Default value is nil
    2. A child route may include a `SectionName` when its `ParentRef` is a route.
        1. A child route “attaches" to the parent route’s `RouteRule` that matches
           that `SectionName`. The child route must also match the criteria
           specified in the `RouteRule’s AllowedRoutes`.
    3. If the `ParentRefs` of a child route doesn’t include a `SectionName`, the
       child route attaches to all of the Parent Route’s `RouteRules` having
       `AllowedRoutes` criteria that the child route meets.
5. A parent `Route` and any related child `Routes` must be the same type of
   `Routes`.
    1. Example: A child httpRoute can not point to a parent tcpRoute.
6. A `Route` MUST NOT be a parent to a `Route` AND a child of another `Route`.
    1. Explanation: This limitation avoids the need for specific
       internal/terminal Route types, and the design of using a ParentRef from
       the child to an AllowedRoutes slot on a parent allows a Route to know if
       it is either a parent or child (or misconfigured as both) without
       requiring the graph traversal that a design like ForwardTo may need to
       avoid cycles.
    2. If an implementation chooses to not enforce this limitation, that must be
       documented along with how many tiers of parent/child route relationships
       are allowed
7. A Route’s `ParentRefs` can list more than one type of parent.
    1. Example: A `HTTPRoute`’s ParentRefs can list one (or more) `Gateways` and
       one (or more) HTTPpRoutes at the same time.

## Binding Parent and Child Routes

Binding a child route to a parent route refers to the process of reconciling (i.e. combining) the two routes. Binding is treated as a single transaction for each Parent/Child route pair. Even when a child route attaches to multiple `RouteRules` in the parent route, the binding between the two routes is still a single transaction.

During the reconciliation process, any conflict of configuration settings between the parent and child routes is considered fatal to the transaction and the entire Binding fails. When a parent route's binding to a child route fails, that does not (directly) block the parent route's bindings with other child routes. In the same way, a child route failing to bind with a parent route does not block that child's bindings to other parent routes.

## Reconciling Parent and Child Routes

A key principle guiding the design of how parent and child routes are combined, is that the data plane can apply the resulting route settings in a single processing cycle (per direction) of the network traffic.

NOTE: In the rest of this sections, the term configuration "object" can also represent a config parameter or an array of either.which of those it represents depends on the specific config setting it is being applied to and what the containing object supports.

Conceptually, the basic the way a parent `Route` and child `Routes` are combined is that, an object in the parent route is added (logical AND) to **each** equivalent object(s) in the child route. This starts at the top layer of objects and is repeated, in sequence, down each layer.

For any given level of config objects there may be a 1-to-many relationship. As an example, the settings in the parent's`RouteRule` are "added" to each of the child's `RouteRule`'s.

Some specific types of objects and config parameters have unique rules for how the parent and child are combined. These are described below.

### Hostname Settings

In the current version of the standard,  hostname can be specified at both the listener and route level. When both are specified, each is treated at a partial FQDN and the two strings are combined at the point of overlap. In this proposal, that model is extended to allow hostname to be specified at the listener, parent route **and** child route levels. Specifying hostname at any combination of these levels is allowed but the hostnames are always combined in the sequence: listener, parent route, child route.  

### RouteMatches

The match criteria from the associated sectionName of the parent route’s `RouteRule`, are added (logical AND) to each `RouteMatch` in the child route’s `RouteRules`. Arrays of matching criteria are evaluated, based on the existing rules for that type of array, before being AND'ed with the matching array from the other route.

There are specific rules for how some types of matches are combined. These are described below.

#### Path Matching

The model described above is simple to understand and apply with all types of matching criteria except for path matching. There are two reasons path matching is different.

First, the user may want to match routes in the child using paths that are relative to the path in the parent route’s match criteria.

The second reason is that there are multiple methods supported for doing path matching. These include prefix, postfix and RegEx. Trying to reconcile two path matching rules could be very complex and prone to error.

**NOTE: Listed below are two proposed options for how patch matching is handled. Which option is used for this GEP will be decided, before this GEP is finalized, based on the communities feedback.**

Options 1:
> To avoid these issues, the only explicitly supported pattern for using path matching, in both a parent and a child route, is using the matching type `PathPrefix` in both routes. The two paths are concatenated to form the complete path to be matched. When being concatenated. the path from the child is added to the end of the parent’s path.

Option 2:
> To avoid these issues, when`httpPathMatch` is set in both the parent and child `RouteMatch`, the parent's match type must be `PathPrefix` and the child's can be `PathPrefix` OR `PathPostfix`.
>
> When the child's is `PathPrefix`, the two paths are concatenated (by adding the child's to the end of the parent's) to form the complete path to be matched.
>
> When the child's match type is `PathPostfix`, the two paths are concatenated but with a "match any" inserted between them. That logic can be expressed with the formula (*[parent PathPrefix]* + "\*" + *[child PathPostfix]*) 

#### Method Matching
A `HHTPMethodMatch` 

<!-- TO DO -->

### RouteFilters

The filters specified in the associated sectionName of the parent route’s RouteRules, are added (logical AND) to each RouteFilter in the child route’s RouteRules.

<!-- TO DO -->

### Example Reconciliation of Parent and Child Routes

<!-- Intro text goes here -->

![Reconciling Routes Example](images/1058-reconciling-routes.png "Example of Reconciling Routes")

### Summary of Changes, Requirements and Constraints: Binding and Reconciling Route

1. 
1. if `HTTPPathMatch` is configured in both the parent and child `Routes`, allow **only** substring prefix matching on path, ithout any wildcard or RegEx matching, 
    1. As suggested in [this comment in GitHub Issue #634][gh-issue-634-comment] to avoid cycles.
1. Extend, to child routes, the current model of configuring the hostname at both the Listener and Route.
    1. Allow setting hostname matching at any combination of lister, parent route and child route.  No change to the current way of combining the values of hostname when set at more than one level.




## Route Status

Note: The details for how route status will be handled are still being worked on and will be added in the near feature.




<!-- Reference links go below this line -->

[gep-724]: https://gateway-api.sigs.k8s.io/geps/gep-724/ "GEP-724: Refresh Route-Gateway Binding"
[httpRouteRule]: https://gateway-api.sigs.k8s.io/v1alpha2/references/spec/#gateway.networking.k8s.io/v1alpha2.HTTPRouteRule
[sectionName]: https://gateway-api.sigs.k8s.io/v1alpha2/references/spec/#gateway.networking.k8s.io/v1alpha2.SectionName
[gh-issue-634-comment]: https://github.com/kubernetes-sigs/gateway-api/issues/634#issuecomment-841930457
